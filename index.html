<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>自走棋：備戰與戰鬥循環</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: #eee; font-family: sans-serif; margin: 0; overflow: hidden; }
        #ui-layer { width: 640px; display: flex; justify-content: space-between; padding: 10px; background: #333; }
        canvas { border: 2px solid #555; background: #2c3e50; }
        .timer { font-size: 24px; font-weight: bold; color: #f1c40f; }
        .phase-name { font-size: 20px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="phase-name" id="phaseDisplay">階段：備備戰中</div>
        <div class="timer" id="timerDisplay">30s</div>
    </div>
    <canvas id="gameCanvas" width="640" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const phaseDisplay = document.getElementById('phaseDisplay');
const timerDisplay = document.getElementById('timerDisplay');

// 遊戲常量
const TILE_SIZE = 80;
const ROWS = 5; // 戰鬥區域
const COLS = 8;
const SHOP_Y = 480; // 商店起始高度

// 遊戲狀態
const PHASES = { PREP: '備戰階段', BATTLE: '戰鬥階段' };
let currentPhase = PHASES.PREP;
let timeLeft = 30;
let lastTime = Date.now();

// 棋子池
const CHAMP_POOL = ["蓋倫", "諾叔", "艾希", "拉克絲", "犽宿"];

// 商店資料
let shopSlots = [];
let draggingItem = null;
let playerUnit = null; // 玩家場上的棋子
let enemyUnit = null;  // 電腦棋子

function initShop() {
    shopSlots = [];
    for(let i=0; i<5; i++) {
        const name = CHAMP_POOL[Math.floor(Math.random() * CHAMP_POOL.length)];
        shopSlots.push({
            name: name,
            x: i * 120 + 60,
            y: SHOP_Y + 60,
            width: 100,
            height: 60,
            color: "#8e44ad"
        });
    }
}

// 初始化一個電腦對手
function spawnEnemy() {
    enemyUnit = {
        name: "電腦小兵",
        gridX: 6,
        gridY: 2,
        hp: 200, maxHp: 200, mp: 0, maxMp: 100,
        color: "#e74c3c", team: "Red",
        x: 0, y: 0
    };
    updatePixelPos(enemyUnit);
}

function updatePixelPos(unit) {
    unit.x = unit.gridX * TILE_SIZE + TILE_SIZE / 2;
    unit.y = unit.gridY * TILE_SIZE + TILE_SIZE / 2;
}

// 滑鼠事件
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousedown', (e) => {
    if (currentPhase !== PHASES.PREP) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    shopSlots.forEach((slot, index) => {
        if (x > slot.x - 50 && x < slot.x + 50 && y > slot.y - 30 && y < slot.y + 30) {
            draggingItem = { ...slot, shopIndex: index };
        }
    });
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

canvas.addEventListener('mouseup', (e) => {
    if (draggingItem) {
        // 判斷是否放在戰鬥格內 (前三行)
        const gx = Math.floor(mouseX / TILE_SIZE);
        const gy = Math.floor(mouseY / TILE_SIZE);

        if (gy < ROWS && gx < COLS) {
            playerUnit = {
                name: draggingItem.name,
                gridX: gx, gridY: gy,
                hp: 200, maxHp: 200, mp: 0, maxMp: 100,
                color: "#3498db", team: "Blue"
            };
            updatePixelPos(playerUnit);
            shopSlots[draggingItem.shopIndex] = { name: "已售出", color: "#555" }; // 買完變灰色
        }
        draggingItem = null;
    }
});

// 戰鬥邏輯
function battleLogic() {
    if (!playerUnit || !enemyUnit) return;
    
    // 簡單的互相扣血
    if (Math.abs(playerUnit.gridX - enemyUnit.gridX) + Math.abs(playerUnit.gridY - enemyUnit.gridY) <= 1) {
        playerUnit.hp -= 0.5;
        enemyUnit.hp -= 0.5;
    } else {
        // 向對方移動
        if (playerUnit.gridX < enemyUnit.gridX) playerUnit.gridX++;
        updatePixelPos(playerUnit);
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. 畫格子
    ctx.strokeStyle = "#444";
    for(let i=0; i<=COLS; i++) {
        ctx.beginPath(); ctx.moveTo(i*TILE_SIZE, 0); ctx.lineTo(i*TILE_SIZE, ROWS*TILE_SIZE); ctx.stroke();
    }
    for(let j=0; j<=ROWS; j++) {
        ctx.beginPath(); ctx.moveTo(0, j*TILE_SIZE); ctx.lineTo(COLS*TILE_SIZE, j*TILE_SIZE); ctx.stroke();
    }

    // 2. 畫商店區
    ctx.fillStyle = "#444";
    ctx.fillRect(0, SHOP_Y, canvas.width, 120);
    shopSlots.forEach(slot => {
        ctx.fillStyle = slot.color || "#8e44ad";
        ctx.fillRect(slot.x - 50, slot.y - 30, 100, 60);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.fillText(slot.name, slot.x, slot.y + 5);
    });

    // 3. 畫棋子
    if (playerUnit) drawUnit(playerUnit);
    if (enemyUnit) drawUnit(enemyUnit);

    // 4. 畫拖曳中的影子
    if (draggingItem) {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "yellow";
        ctx.fillRect(mouseX - 50, mouseY - 30, 100, 60);
        ctx.globalAlpha = 1.0;
    }
}

function drawUnit(unit) {
    if (unit.hp <= 0) return;
    ctx.fillStyle = unit.color;
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, 25, 0, Math.PI*2);
    ctx.fill();
    // 血條
    ctx.fillStyle = "red";
    ctx.fillRect(unit.x - 25, unit.y - 40, 50, 5);
    ctx.fillStyle = "green";
    ctx.fillRect(unit.x - 25, unit.y - 40, (unit.hp/unit.maxHp)*50, 5);
    ctx.fillStyle = "white";
    ctx.fillText(unit.name, unit.x, unit.y + 5);
}

// 核心循環與計時器
function update() {
    const now = Date.now();
    if (now - lastTime >= 1000) {
        timeLeft--;
        lastTime = now;
        if (timeLeft <= 0) {
            // 切換階段
            if (currentPhase === PHASES.PREP) {
                currentPhase = PHASES.BATTLE;
                timeLeft = 30;
                spawnEnemy();
            } else {
                currentPhase = PHASES.PREP;
                timeLeft = 30;
                playerUnit = null; // 回合結束清空場地
                enemyUnit = null;
                initShop();
            }
        }
    }

    if (currentPhase === PHASES.BATTLE) {
        battleLogic();
    }

    phaseDisplay.innerText = `階段：${currentPhase}`;
    timerDisplay.innerText = `${timeLeft}s`;

    draw();
    requestAnimationFrame(update);
}

initShop();
update();
</script>
</body>
</html>
</body>
</html>
